
> Undestanding TypeScript

COMMANDS:
> npm init -y 'project'
> npm install typescript --only=dev

| TypeScript is the types |
_______________________________________________________________________________________

   - String:
         {need to surround it with double (") or single (') quotes, or the (`) grave accent, commonly known as a template string.}
        [
            Declaring template strings inside text is not a problem with TypeScript. 
            Template strings are a feature in ECMAScript that made it possible to add a variable inside
            a string without the need for concatenation:
        ]

        EXAMPLE:
            const myText: string = 'My Simple Text';
            const myTextAgain: string = "My Simple Text";
            const greeting: string = `Welcome back ${myName}!`;

    
    - Number: { all numbers are floating-point values }
        [
             In addition to the hexadecimal and decimal numbers, 
             the binary and octal literals that were introduced 
             in ECMAScript 2015 are treated like numbers too:
        ]

        EXAMPLE:
            const myAge: number = 31;
            const hexNumber: number = 0xf010d;
            const binaryNumber: number = 0b1011;
            const octalNumber: number = 0o744;


    - Boolean   {a simple 1 or 0, and true or false.}
        
        EXAMPLE:
            const isTaskDone: boolean = false;
            const isGreaterThen: boolean = 10 > 5;



    - Arrays:

        Declare the type of the element followed by [] (square brackets)
            
            EXAMPLE:
                const primeNumbers: number[] = [1, 3, 5, 7, 11];
        
        Or, you can declare generically, using the Array<type> declaration. This is not the most common way used,

            EXAMPLE:
            const switchInstructions: Array<boolean> = [true, false, false, true];


        
        
    - Tuple: {. Structurally, a tuple is an array of two elements}
        [
            both are a known type by the compiler and the user,
            but those elements don't need to have the same type:
        ]

        EXAMPLE:
            let person: [string, number];
            person = ['Heitor', 31];
            console.log(`My name is ${person[0]} and I am ${person[1]} years old`);   


        NOTE:
            If you try to access an element outside of the known indices, you will get an error.


    - Enum: 
        { A numeric enum can be created without any declaration }
            [
                By doing this, it will start with the initial values of 0 
                and finish with the value of the final index number; 
                or, you can get the name of the enum, passing the index of
                the enum value.
            ]

            EXAMPLE:
                enum ErrorLevel { 
                    Info, 
                    Debug, 
                    Warning, 
                    Error, 
                    Critical,
                }
                console.log(ErrorLevel.Error); // 3
                console.log(ErrorLevel[3]); // Error


        { Or, an enum can be declared with values. }

            [
                 It can be an initial declaration that the TypeScript 
                 compiler will interpret the rest of the elements 
                 as an increment of the first one, or an individual 
                 declaration:
            ]

            EXAMPLE:
            enum Color {
                Red = '#FF0000',
                Blue = '#0000FF',
                Green = '#00FF00',
            }

            enum Languages {
                JavaScript = 1,
                PHP,
                Python,
                Java = 10,
                Ruby,
                Rust,
                TypeScript,
            }

            console.log(Color.Red) // '#FF0000'
            console.log(Languages.TypeScript) // 13


    - Any:   { TypeScript needed to implement a type that has no defined value, so it implemented the any type.  }

            [
                The most used case for the any type any is when using values
                that came from a third-party library. In that case,
                we know that we are dropping the type checking: 
            ]

            EXAMPLE:
                let maybeIs: any = 4;
                maybeIs = 'a string?';
                maybeIs = true;
            
            NOTE:
                [
                    The main use of the any type is when you are upgrading a
                    legacy JavaScript project to TypeScript, 
                    and you can gradually add the types and validations 
                    to the variables and functions. 
                ]

            
    - Void: 
        { As the opposite of any, void is the absence of the type at all }
        
            [
                The most used case is with functions 
                that won't return any values:
            ]

            EXAMPLE:
                function logThis(str: string): void{
                    console.log(str);
                }
            NOTE:
                [
                    Using void to type a variable is useless because it only
                    can be assigned to undefined and null.
                ]

    - Objects
        [
            It can be declared as an interface, 
            As a direct object, 
            Or as a type of its own.  
        ]

        { 
            Declaring an object as an interface, 
            you have to declare the interface before using it, 
            all the attributes must be passed, and the types need to be set: 
        }
        EXAMPLE:
            interface IPerson {
                name: string;
                age: number;
            }

            const person: IPerson = {
                name: 'Heitor',
                age: 31,
            };

        { 
            Using objects as direct inputs is sometimes
             common when passing to a function: 
        }
        EXAMPLE:
            function greetingUser(user: {name: string, lastName: string}) {
                console.log(`Hello, ${user.name} ${user.lastName}`);
            }
        
        { 
            And finally, they are used for declaring 
            a type of object and reusing it:
        }
        EXAMPLE:
            type Person = {
                name: string,
                age: number,
            };

            const person: Person = {
                name: 'Heitor',
                age: 31,
            };

            console.log(`My name is ${person.name}, I am ${person.age} years old`);


    - Functions
        [ 
            Declaring a function in TypeScript is a 
            composition of the parameters that the function 
            will receive and the final type that the function
            will return.
        ]

        { 
            declare a simple function inside a constant, like this: 
        }
        EXAMPLE:

            const sumOfValues: (a:number, b:number): number = (a: number, b: number): number => a + b;
        
        {
            A more complex function declared inside a constant.
        }
        EXAMPLE:
            const complexFunction: (a: number) => (b:number) => number = (a: number): (b: number) => number => (b: number): number => a + b;

        {
            When declaring a function as a normal function, 
            the way to type it is almost the same as in a 
            constant way, but you don't need to declare 
            that the functions are a function. Here is an example:
        }
        EXAMPLE:
        function foo(a: number, b:number): number{
            return a + b;
        }     

    -Interfaces:
        {
            checks that the values of variables are the
            correct type and the same principle is applied 
            to classes, objects, or contracts 
            Interfaces exist to fill this space and define 
            these contracts or types.
        }
        EXAMPLE:

            function greetingStudent(student: {name: string}){
                console.log(`Hello ${student.name}`);
            }
            const newStudent = {name: 'Heitor'};
            greetingStudent(newStudent);

            ** The function will know that the object has the 
                property name on it and that it's valid to call it.**

        { rewrite it with the interface type for better code management }

            interface IStudent {
                name: string;
                course?: string;  (?) called optional property
                readonly university: string; (property read-only.)
            }

            function greetingStudent(student: IStudent){
                console.log(`Hello ${student.name}`);
                if(student.course){
                    console.log(`Welcome to the ${student.course}` semester`);
                }
            }
            const newStudent: IStudent = { name: 'Heitor', university: 'UDF' };
            greetingStudent(newStudent);

    
    -Decorators: { Decorators provide a way to add both annotations and meta-programming syntax to class declarations and its member }
        [
            As it's in a final state of approval on the TC-39 
            committee (where TC stands for Technical Committee), 
            the TypeScript compiler already has this available to be used.
        ]
        EXAMPLE: 
            { To enable it,set the flags on the tsconfig.json file:  }
            
            {
                "compilerOptions": {
                    "target": "ES5",
                    "experimentalDecorators": true
                }
            } 

            [
                Decorators are a special kind of declaration that 
                can be attached to a:
                    - class: 
                    EXAMPLE:
                        function classSeal(constructor: Function) {
                            Object.seal(constructor);
                            Object.seal(constructor.prototype);
                        } //When you create this function, you are saying that the object of the constructor and the prototype of it will be sealed.

                        @classSeal
                        class Animal {
                            sound: string;
                            constructor(sound: string) {
                                this.sound = sound;
                            }
                            emitSound() {
                                return "The animal says, " + this.sound;
                            }
                        }


                    - method:

                    - accessor property, 
                    - or parameter. 
                They are used in the form of @expression, 
                where the expression is a function that will 
                be called at runtime.
            ]
            {  }

            See also:
                You can find more information about TypeScript basic types at https://www.typescriptlang.org/docs/handbook/basic-types.html.
                You can find more information about TypeScript functions at https://www.typescriptlang.org/docs/handbook/functions.html.
                You can find more information about TypeScript enums at https://www.typescriptlang.org/docs/handbook/enums.html.    
                You can find more information about TypeScript advanced types at https://www.typescriptlang.org/docs/handbook/advanced-types.html.  
                You can find more information about TypeScript decorators at https://www.typescriptlang.org/docs/handbook/decorators.html.
                View a cheatsheet on TypeScript types at https://rmolinamir.github.io/typescript-cheatsheet/#types.






            



        










